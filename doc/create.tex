\Chapter{Creating quasigroups and loops}

In this chapter we describe several ways in which quasigroups and loops can be created in {\LOOPS}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{About Cayley tables}

Let $X=\{x_1,\dots,x_n\}$ be a set and $\cdot$ a binary operation on $X$. Then
an $n$ by $n$ array with rows and columns bordered by $x_1$, $\dots$, $x_n$, in
this order, is a <Cayley table>
%
\index{Cayley table}
%
, or a <multiplication table>
%
\index{multiplication table}
%
 of
$\cdot$, if the entry in the row $x_i$ and column $x_j$ is $x_i\cdot x_j$.

A Cayley table is a <quasigroup table>
%
\index{quasigroup table}
%
 if it is a <Latin square>
%
\index{Latin square}
%
,
i.e., if every entry $x_i$ appears in every column and every row exactly once.

An annoying feature of quasigroup tables in practice is that they are often not
bordered, and it is up to the reader to figure out what is meant. Throughout
this manual and in {\LOOPS}, we therefore make the following assumption: <All
distinct entries in a quasigroup table must be integers, say>
$x_1\<x_2\<\cdots\<x_n$<, and if no border is specified, we assume that the
table is bordered by> $x_1$, $\dots$, $x_n$<, in this order.> Note that we do
not assume that the distinct entries $x_1$, $\dots$, $x_n$ form the interval
$1$, $\dots$, $n$. The significance of this observation will become clear in
Chapter "Methods based on permutation groups".

Finally, we say that a quasigroup table is a <loop table>
%
\index{loop table}
%
 if the first row
and the first column are the same, and if the entries in the first row are
ordered in an ascending fashion.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Testing Cayley tables}

A square array with integral entries is called a <matrix> in {\GAP}. The
following synonymous operations test if a matrix $T$ is a quasigroup table, as
defined above:

\>IsQuasigroupTable( <T> ) O
\>IsQuasigroupCayleyTable( <T> ) O

The following synonymous operations test if a matrix $T$ is a loop table:

\>IsLoopTable( <T> ) O
\>IsLoopCayleyTable( <T> ) O

We would like to call attention to the fact that the package \package{GUAVA}
also has some operations dealing with Latin squares. In particular,
`IsLatinSquare' is declared in \package{GUAVA}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Canonical and normalized Cayley tables}

Although we do not assume that a quasigroup table with distinct entries
$x_1\<\cdots\<x_n$ satisfies $x_i=i$, it is often desirable to present
quasigroup tables in the latter way. The rather general operation

\>CanonicalCayleyTable( <T> ) O

takes any Cayley table $T$ with distinct entries $x_1\<\cdots\<x_n$, and
returns a Cayley table in which $x_i$ has been replaced by $i$.

The operation

\>NormalizedQuasigroupTable( <T> )

makes a quasigroup table $T$ into a loop table by:
\beginlist%unordered
\item{$\circ$} first calling `CanonicalCayleyTable' to rename the entries to $1$,
    $\dots$, $n$,
\item{$\circ$} then permuting the columns of $T$ so that the first row reads
    $1$, $\dots$, $n$,
\item{$\circ$} and then permuting the rows of $T$ so that the first column
    reads $1$, $\dots$, $n$.
\endlist

Here is an example for methods concerning Cayley tables:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating quasigroups and loops manually}

When $T$ is a quasigroup table, the corresponding quasigroup is obtained by

\>QuasigroupByCayleyTable( <T> ) O

Since `CanonicalCayleyTable' is called within the above operation, the
resulting quasigroup will have a Cayley table with distinct entries $1$,
$\dots$, $n$.

Here is the analogous operation for a loop table $T$:

\>LoopByCayleyTable( <T> ) O

And here is an example for methods concerning Cayley tables:

\beginexample
gap> ct := CanonicalCayleyTable( [[5,3],[3,5]] );
[ [ 2, 1 ], [ 1, 2 ] ]
gap> NormalizedQuasigroupTable( ct );
[ [ 1, 2 ], [ 2, 1 ] ]
gap> LoopByCayleyTable( last );
<loop of order 2>
gap> [ IsQuasigroupTable( ct ), IsLoopTable( ct ) ];
[ true, false ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating quasigroups and loops from a file}

Typing a large multiplication table manually is tedious and error-prone. We
have therefore included a universal algorithm in {\LOOPS} that reads
multiplication tables of quasigroups from a file.

Instead of writing a separate algorithm for each common format, our algorithm
relies on the user to provide a bit of information about the input file. Here
is an outline of the algorithm, with file named $F$ and a string $D$ as
arguments on the input:
\beginlist%unordered
\item{$\circ$} read the entire content of $F$ into a string $S$,
\item{$\circ$} replace all end-of-line characters in $S$ by spaces,
\item{$\circ$} replace by spaces all characters of $S$ that appear in $D$,
\item{$\circ$} split $S$ into maximal substrings without spaces, called
    <chunks>,
\item{$\circ$} recognize distinct chunks (let $n$ be the number of distinct
    chunks),
\item{$\circ$} if the number of chunks is not $n^2$, report error,
\item{$\circ$} construct the multiplication table by assigning numerical
    values $1$, $\dots$, $n$ to chunks, depending on their position among
    distinct chunks.
\endlist

The following examples clarify the algorithm and document its versatility. All
examples are of the form $F+D\Longrightarrow T$, meaning that an input file
containing $F$ together with the string $D$ produce multiplication table $T$.

\medskip

% begin examples for LoopFromFile
*Example 1:* Data does not have to be arranged into an array of any kind.
$$
\matrix{
    \matrix{
        0&1&2&1\cr
        2&0&2& \cr
        0&1& &
    }&
    +&
    ''''&
    \Longrightarrow&
    \matrix{
        1&2&3\cr
        2&3&1\cr
        3&1&2
    }
}
$$

*Example 2:* Chunks can be any strings.
$$
\matrix{
    \matrix{
        {\rm{red}}&{\rm{green}}\cr
        {\rm{green}}&{\rm{red}}
    }&
    +&
    ''''&
    \Longrightarrow&
    \matrix{
        1& 2\cr
        2& 1
    }
}
$$

*Example 3:* A typical table produced by {\GAP} is easily parsed by deleting
brackets and commas.
$$
\matrix{
    [\ [0, 1],\ [1, 0]\ ]&
    +&
    ''[,]''&
    \Longrightarrow
     \matrix{
        1& 2\cr
        2& 1
    }
}
$$

*Example 4:* A typical {\TeX} table with rows separated by lines is also easily
converted. Note that we have to use $\backslash\backslash$ to make sure that
every occurrence of $\backslash$ is deleted, since $\backslash\backslash$
represents the character $\backslash$ in {\GAP}.
$$
\matrix{
    \matrix{
        {\rm{x\&\ y\&\ z\backslash{cr}}}\cr
        {\rm{y\&\ z\&\ x\backslash{cr}}}\cr
        {\rm{z\&\ x\&\ y}}
    }
    +&
    ''\backslash\backslash{\rm{cr\&}}''&
    \Longrightarrow&
    \matrix{
        1&2&3\cr
        2&3&1\cr
        3&1&2
    }
}
$$
% end examples for LoopFromFile

\medskip

And here are the needed ${\LOOPS}$ commands:

\>QuasigroupFromFile( <F>, <D> ) O
\>LoopFromFile( <F>, <D> ) O

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating quasigroups and loops by sections}

Let $G$ be a group, $H$ a subgroup, and $T$ a left transversal to $H$ in $G$.
Then the operation $\circ$ defined on the left cosets $Q = \{tH;\;t\in T\}$ by
$tH\circ t'H = (tt')H$ turns $Q$ into a quasigroup. In fact, every quasigroup
$Q$ can be obtained in this way (let $G={\rm{Mlt}}(Q)$, $H={\rm{LMlt}}(Q)$ and
$T=\{L_x;\;x\in Q\}$).

The resulting quasigroup (or loop) is returned via

\>QuasigroupByLeftSection( <H>, <T> ) O
\>LoopByLeftSection( <H>, <T> ) O

The following example is more important than it looks (see \cite{NagyBol}):

\beginexample
gap> H := Group( (1,2,3,4), (5,6), (6,7) );;
gap> T:= List( Group((1,2), (1,2,3,4)), x -> x^(-1)*x^(1,5)(2,6)(3,7)(4,8));;
gap> L := LoopByLeftSection( H, T );
<loop of order 24>
gap> [ IsLeftBolLoop( L ), IsMoufangLoop( L ), IsSimple( L ) ];
[ true, false, true ]
\endexample

In the above setting, each element $t$ of $T$ determines a permutation of $Q$,
a left translation by $t$. More generally, if $S$ is a list of permutations
that correspond to all left translations in a quasigroup or a loop $Q$, the
quasigroup or loop $Q$ is returned by

\>QuasigroupByLeftSection( <S> ) O
\>LoopByLeftSection( <S> ) O

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating quasigroups and loops by extensions}

If $Q$ is a loop and $K$ an abelian subgroup of $N(Q)$ then

\>NuclearExtension( <Q>, <K> ) O

returns $[K_0, F, \varphi, \theta]$, where $K_0\cong K$, $F\cong Q/K$,
$\varphi:F\to{\rm{Aut}}{K}$ is a homomorphism, $\theta:F\times F\to K$ is a
cocycle, and $Q$ is isomorphic to $K_0\times F$ with multiplication $(a,x)(b,y)
= (a\varphi_x(b)\theta(x,y),xy)$.

If $n=|F|$ and $m=|K|$, the cocycle $\theta$ is returned as an $n\times n$
array with entries in $\{1,\dots,m\}$, and $\varphi$ is returned as a list of
length $n$ of permutations of $\{1,\dots,m\}$.

Conversely, given $K$, $F$, $f = \varphi$, and $t = \theta$ as above,

\>LoopByExtension( <K>, <F>, <f>, <t> ) O

returns the extension of $K$ by $F$ using the action $f$ and cocycle $t$.

\beginexample
gap> F := AsLoop( Group( (1,2) ) );
<loop of order 2>
gap> K := DirectProduct( F, F );;
gap> phi := [ (), (2,3) ];;
gap> theta := [ [ 1, 1 ], [ 1, 3 ] ];;
gap> LoopByExtension( K, F, phi, theta );
<loop of order 8>
gap> IsAssociative( last );
false
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Conversions}

As we have already mentioned, \LOOPS\ contains operations that convert
between magmas, quasigroups, loops and groups, provided such conversions are
possible.

If $M$ is a declared magma that happens to be a quasigroup, the corresponding
quasigroup is returned via

\>AsQuasigroup( <M> ) O

Given a quasigroup $M$ and two of its elements $f$, $g$, the principal loop
isotope $x\circ y = R_g^{-1}(x)\cdot L_f^{-1}(y)$ turns $(M,\circ)$ into a loop
with neutral element $f\cdot g$ (see Section "Homomorphisms and homotopisms").
Since loops in \LOOPS\ have to have neutral element labelled as $1$, the
function

\>PrincipalLoopIsotope( <M>, <f>, <g> )

returns an isomorphic copy of the principal isotope $(M,\circ)$ via the
transposition $(1,f\cdot g)$.

If $M$ is a magma that happens to be a quasigroup, the operation

\>AsLoop( <M> ) O

returns a loop $L$ as follows:
\beginlist%unordered
\item{$\circ$}
    if $M$ possesses a neutral element $e$ and $f$ is the first element of $M$,
    then $L$ is an isomorphic copy of $M$ via the transposition $(e,f)$,
\item{$\circ$}
    if $M$ does not posses a neutral element, $L$ is returned as
    `PrincipalLoopIsotope( <M>, <M.1>, <M.1> )'
\endlist

One could obtain a loop from $M$ in yet another way, by normalizing the Cayley
table of $M$. These three approaches can result in nonisomorphic loops in
general.

Finally, when $M$ is a declared magma that happens to be a group, then the
corresponding group is returned by

\>AsGroup( <M> ) A

Note that the conversions work in both directions, not just toward more special
structures. Thus, if $G$ is a declared group, then `AsLoop( <G> )' returns the
corresponding loop, for instance.

Also see `IsomorphicCopyByPerm'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Products of loops}

\noindent Let $L1$, $\dots$, $Ln$ be a list consisting of loops and groups,
where $n\ge 1$. Then

\>DirectProduct( <L1>, ..., <Ln>) O

returns the direct product of $L1$, $\dots$, $Ln$.

If there are only groups among $L1$, $\dots$, $Ln$, a group is returned.
Otherwise a loop is returned. If $n=1$, $L1$ is returned.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Opposite quasigroups and loops}

When $Q$ is a quasigroup with multiplication $\cdot$, the <opposite quasigroup>
%
\index{opposite quasigroup}
%
 of $Q$ is a quasigroup with the same underlying set as $Q$ and with
multiplication $*$ defined by $x*y=y\cdot x$.

Since the quasigroup-theoretical concepts are often chiral (cf. left Bol loops
versus right Bol loops), it is useful to have access to the opposite quasigroup
of $Q$:

\>Opposite( <Q> ) O
